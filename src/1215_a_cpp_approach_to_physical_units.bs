<pre class='metadata'>
Title: A C++ Approach to Physical Units
Shortname: D1215
Revision: 0
Status: D
Group: WG21
Audience: SG6, LEWG
URL: https://mpusz.github.io/wg21-papers/papers/1215_a_cpp_approach_to_physical_units.html
Editor: Mateusz Pusz, Epam Systems http://www.epam.com, mateusz.pusz@gmail.com, http://www.train-it.eu
Abstract: TBD 
Repository: mpusz/wg21_papers
!Source: <a href="https://github.com/mpusz/wg21_papers/blob/master/src/1215_a_cpp_approach_to_physical_units.bs">github.com/mpusz/wg21_papers/blob/master/src/1215_a_cpp_approach_to_physical_units.bs</a>
Markup Shorthands: markdown on
</pre>



Introduction {#introduction}
============================

Overview {#overview}
--------------------

The human history knows many expensive failures and accidents caused by mistakes in calculations involving
different physical units. The most famous example in the software engineering domain is the Mars Climate Orbiter
that in 1999 failed to entered Mars orbit and crashed while entering its atmosphere
[[MARS_ORBITER]]. That is not the only example here. People tend to confuse
units quite often. We see similar errors occurring in various domains through the years:
- On 12 october, 1492 Christopher Columbus unintentionally discovered America because during his travel preparations
    he mixed Arabic mile with a Roman mile witch led to wrong estimation of equator and his expected travel distance
    [[COLUMBUS]]
- Air Canada Flight 143 ran out of fuel on July 23, 1983, at an altitude of 41 000 feet (12 000 metre),
    midway through the flight because the fuel had been calculated in pounds instead of kilograms by the ground crew
    [[GIMLI_GLIDER]]
- On April 15, 1999, Korean Air Cargo Flight 6316 crashed due to the miscommunication between pilots about desired
    flight altitude [[FLIGHT_6316]]
- In February 2001 Zoo crew built an enclosure for Clarence the Tortoise with a weight of 250 pounds instead of 250 kilogram
    [[CLARENCE]]
- In December 2003, one of the cars at Tokyo Disneyland’s Space Mountain attraction suddenly derailed due to a broken
    axle caused by the confusion after upgrading the specification from imperial to metric units [[DISNEY]]
- An American company sold a shipment of wild rice to a Japanese customer, quoting a price of 39 cent per pound, but the
    customer thought the quote was for 39 cent per kilogram [[WILD_RICE]]
- A whole set of medication dose errors...

Lack of strong types {#lack-of-strong-types}
--------------------------------------------

It turns out that in C++ software most of our calculations in this domain is handled with fundamental types like
`double`. Code like below is a typical example here:

```cpp
double GlidePolar::MacCreadyAltitude(double emcready, 
                                     double Distance, 
                                     const double Bearing, 
                                     const double WindSpeed, 
                                     const double WindBearing, 
                                     double *BestCruiseTrack,
                                     double *VMacCready, 
                                     const bool isFinalGlide,
                                     double *TimeToGo,
                                     const double AltitudeAboveTarget,
                                     const double cruise_efficiency,
                                     const double TaskAltDiff);
```

Even though this example comes from an Open Source project, expensive revenue-generating production source code
often does not differ too much. We lack strong typedefs feature in the core language and without it we are often
too lazy to handcraft a new class type for each use case.

Proliferation of magic numbers {#magic-numbers}
-----------------------------------------------

There is a lot of constants and conversion factors involved in dimensional analysis. Source code handling
responsible for doing such computations is often trashed with magic numbers:

```cpp
// Air Density(kg/m3) from relative humidity(%),
// temperature(°C) and absolute pressure(Pa)
double AirDensity(double hr, double temp, double abs_press)
{
  return (1/(287.06*(temp+273.15))) *
         (abs_press - 230.617 * hr * exp((17.5043*temp)/(241.2+temp)));
}
```


Motivation and Scope {#motivation-and-scope}
============================================

Motivation {#motivation}
------------------------

There is a huge demand for a high quality physical units library in the industry and scientific environments.
Code that we write for fun and living should be correct, safe and easy to write. Although there are many such
libraries available on the market none of them is a widely accepted production standard. We could just provide
a yet another 3rd party library covering this topic but it is probably not the best idea.

First of all, software that could benefit from such a library is not a niche on the market. If it was the
case, probably its needs could be fulfilled with a 3rd party highly-specialized and narrow-use library.
Contrary, broad range of production project deal with units conversions and dimensional analysis. Right now
having no other good and easy to access alternatives results in proliferation of plain `double` type usage
to express physical quantities. Space, aviation, automotive, embedded, scientific, computer science and many
other domains could benefit from strong types and conversions provided by such a library. 

Secondly, yet another library will not solve the issue for many customers. Many corporations are not allowed
to use 3rd party libraries in the production code. Also important point here is cooperation of different
products from multiple vendors that use physical quantities as vocabulary types in their interfaces.
From the author's experience gathered while working with multiple corporations all over the world, there
is really a huge difference between the adoption of a mature 3rd party library and the usage of features 
released as a part of the C++ Standard Library. If it were not the case all products would use Boost.Units
already. A motivating example here can be `std::chrono` released as a part of C++11. Right now no one asks
questions how to represent timestamps and how to handle their conversions in the code. `std::chrono` is the
the ultimate answer. So let us try to get `std::units` in the C++ Standard Library too.

Goal {#goal}
--------------------------------------------

The aim of this paper is to standardize a physical units library that enables operations on various dimensions
and units:

```cpp
// simple numeric operations
static_assert(10km / 2 == 5km);

// unit conversions
static_assert(1h == 3600s);
static_assert(1km + 1m == 1001m);

// dimension conversions
static_assert(1km / 1s == 1000mps);
static_assert(2kmph * 2h == 4km);
static_assert(2km / 2kmph == 1h);

static_assert(1000 / 1s == 1kHz);

static_assert(10km / 5km == 2);
```

We intent to provide users with cleaner interfaces by expressing the usage of variables by their type, and not
in comments or documentation:

```cpp
std::units::quantity<> GlidePolar::MacCreadyAltitude(
    std::units::quantity<> emcready, 
    std::units::quantity<> Distance, 
    const std::units::quantity<> Bearing, 
    const std::units::quantity<> WindSpeed, 
    const std::units::quantity<> WindBearing, 
    std::units::quantity<> *BestCruiseTrack,
    std::units::quantity<> *VMacCready, 
    const bool isFinalGlide,
    std::units::quantity<> *TimeToGo,
    const std::units::quantity<> AltitudeAboveTarget,
    const std::units::quantity<> cruise_efficiency,
    const std::units::quantity<> TaskAltDiff);
```

We further aim to provide unit conversion facilities and constants for users to rely on, instead of magic
numbers:

```cpp
// Air Density(kg/m3) from relative humidity(%),
// temperature(°C) and absolute pressure(Pa)
std::units::quantity<std::units::kilogram_per_cubic_metre> AirDensity(
    double hr,
    std::units::quantity<std::units::degree_celsius> temp,
    std::units::quantity<std::units::pascal> abs_press)
{
  return (1/(287.06*(std::unit::quantity_cast<std::unit::degree_kelvin>(temp)))) *
         (abs_press - 230.617 * hr * exp((17.5043*temp)/(241.2+temp)));
}
```

Scope {#scope}
--------------

Although there is public demand for a generic units library that could handle any units and dimensions,
author suggests scoping the Committee efforts only on the physical and possibly computer science
(i.e. `bit`, `bitrate`) units first. The library should be designed in a way to allow easy extensions so
everyone interested might add his own base and derived dimensions if needed (i.e. `coffee/milk/water/sugar` system).

The examples above are thus meant as goal to strive for, but should not necessarily be standardized
immediatly. After releasing a first, restricted version of the library and observing how it is used we can
consider standardizing additional dimensions, units, and constants in the following C++ releases.


Terms and definitions {#terms-and_definitions}
==============================================

Following Boost.Units

<dfn>Base dimension</dfn>
  - measurable entity of interest
  - essentially a tag type and provide no dimensional analysis functionality by itself
  - i.e. length `[L]`, mass `[M]`, time `[T]`, etc.

<dfn>Dimension</dfn>
  - a collection of zero or more base dimensions
  - each potentially raised to a different rational power
  - i.e. length = `[L]`<sup>`1`</sup>, area = `[L]`<sup>`2`</sup>, velocity = `[L]`<sup>`1`</sup>`/[T]`<sup>`1`</sup>, etc.

<dfn>Base unit</dfn>
  - a specific measure of a dimension
  - conversions are defined using base units
  - i.e. `[L]` -> `m` (meter)

<dfn>Unit</dfn>
  - a set of base units raised to rational exponents
  - i.e. `m`<sup>`1`</sup>, `kg`<sup>`1`</sup>, `m`<sup>`1`</sup>`/s`<sup>`2`</sup>, etc.

<dfn>System</dfn>
  - a collection of base units representing all the measurable entities of interest for a specific problem

<dfn>Quantity</dfn>
  - a concrete amount of a unit
  - i.e. `10 meters`



Prior Work {#prior-work}
========================

There are many dimensional analysis libraries available on the market today. Some of them are more successful
than others but none of them is a widely accepted standard in the C++ code base (both Open Source as well as
production code). Next sections of this chapter will describe the most interesting parts of selected libraries. The last section
provides extensive comparison of their main features.

Boost.Units {#boost.units}
--------------------------

Boost.Units [[BOOST.UNITS]] is probably the most widely adopted library in this domain. It was first released
in Boost 


cppnow17-units {#cppnow17-units}
--------------------------------

Steven Watanabe, coauthor of the previous library, started the work on the modernized version of the library
based on the results of LiaW on C++Now 2017 [[CPPNOW17-UNITS]]


PhysUnits-CT-Cpp11 {#PhysUnits-CT-Cpp11}
----------------------------------------

[[PHYSUNITS-CT-CPP11]]

Nic Holthaus units {#nic-units}
-------------------------------

Another interesting library comes from Nic Holthaus [[NIC_UNITS]]. In this library a dimension is
hardcoded in a `base_unit` class template.

```cpp
namespace units {

template<class Meter = detail::meter_ratio<0>,
         class Kilogram = std::ratio<0>,
         class Second = std::ratio<0>,
         class Radian = std::ratio<0>,
         class Ampere = std::ratio<0>,
         class Kelvin = std::ratio<0>,
         class Mole = std::ratio<0>,
         class Candela = std::ratio<0>,
         class Byte = std::ratio<0>>
struct base_unit;

}
```

Unit are expressed as instantiations of `unit` class template.

```cpp
namespace units {

template<class Conversion, class BaseUnit, class PiExponent = std::ratio<0>, class Translation = std::ratio<0>>
struct unit;

}
```

Interesting to notice here are:
- `PiExponent` - an exponent representing factors of PI required by the conversion. (e.g. `std::ratio<-1>` for a radians to degrees conversion)
- `Translation` - a ratio representing a datum translation required for the conversion (e.g. `std::ratio<32>` for a Fahrenheit to Celsius conversion)

```cpp
namespace units {

template<class Units, typename T = UNIT_LIB_DEFAULT_TYPE, template<typename> class NonLinearScale = linear_scale>
class unit_t : public NonLinearScale<T> { ... };

}
```

Interesting to notice here is that beside typical SI dimensions there are also `Radian` and `Byte`.

This library also presents totally different approach than the previous cases. There are no dimension
or quantity types. Every unit is an instantiation of `unit` class template with ratio and a specific
`base_unit` responsible for unit "category". Each "dimension" of unit is defined in its own namespace.
To form a quantity there is additional 

```cpp
namespace units {

namespace category {

typedef base_unit<std::ratio<2>, std::ratio<1>, std::ratio<-3>, std::ratio<0>, std::ratio<-1>> voltage_unit;

}


namespace voltage {

typedef unit<std::ratio<1>, units::category::voltage_unit> volts;
typedef volts volt;
typedef unit_t<volt> volt_t;

}

}
```

To form a value

```cpp
#include <units.h>

using namespace units::literals;

units::voltage::volt_t v = 230_V;
```

Bryan St. Amour units {#bryan-units}
------------------------------------

[[BRYAN_UNITS]]


benri {#benri}
--------------

[[BENRI]]


Michael Ford units {#mikeford3-units}
--------------

[[MIKEFORD3_UNITS]]


`std::chrono::duration` {#chrono::duration}
-------------------------------------------


Comparison {#comparison} 
------------------------

<table>
  <tr>
    <th>Feature</th><th>mp-units</th><th>Boost.Units</th><th>cppnow17-units</th><th>PhysUnits-CT-Cpp11</th><th>nholthaus</th><th>bstamour</th>
  </tr>
  <tr>
    <td>SI</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td>
  </tr>
  <tr>
    <td>Customary system</td><td>yes</td><td>yes</td><td></td><td></td><td>yes</td><td></td>
  </tr>
  <tr>
    <td>Other systems</td><td>???</td><td>yes</td><td></td><td></td><td>yes (`bytes`, `radians`)</td><td></td>
  </tr>
  <tr>
    <td>C++ version</td><td>C++20</td><td>C++98 + `constexpr`</td><td></td><td></td><td>C++14</td><td></td>
  </tr>
  <tr>
    <td>Base dimension id</td><td>string</td><td>integer</td><td></td><td></td><td>index on template parameter list</td><td></td>
  </tr>
  <tr>
    <td>Dimension</td><td>type (`length`)</td><td>type (`length_dimension`)</td><td></td><td></td><td>none</td><td></td>
  </tr>
  <tr>
    <td>Dimension representation</td><td>type list</td><td>type list</td><td></td><td></td><td>Class template arguments</td><td></td>
  </tr>
  <tr>
    <td>Fractional exponents</td><td>yes</td><td>yes</td><td></td><td></td><td>yes</td><td></td>
  </tr>
  <tr>
    <td>Type traits for dimensions</td><td>no</td><td>yes</td><td></td><td></td><td>yes</td><td></td>
  </tr>
  <tr>
    <td>Unit</td><td>type (`metre`)</td><td>type + constant (`si::length` + `si::meter`)</td><td></td><td></td><td>type (`length::meter_t`)</td><td></td>
  </tr>
  <tr>
    <td>UDLs</td><td>yes</td><td>no</td><td></td><td></td><td>yes</td><td></td>
  </tr>
  <tr>
    <td>Predefined scaled unit types</td><td>some</td><td>no</td><td></td><td></td><td>all</td><td></td>
  </tr>
  <tr>
    <td>Scaled units</td><td>type + UDL (`kilometre` + `km`)</td><td>user's type + multiply with constant (`make_scaled_unit<>` + `si::kilo * si::meter`)</td><td></td><td></td><td>type + UDL (`length::kilometer_t` + `_km`)</td><td></td>
  </tr>
  <tr>
    <td>Meter vs metre</td><td>metre</td><td>both</td><td></td><td></td><td>meter</td><td></td>
  </tr>
  <tr>
    <td>Singular vs plural</td><td>singular (`metre`)</td><td>both (`meter` + `meters`)</td><td></td><td></td><td>both (`length::meter_t` + `length::meters_t`)</td><td></td>
  </tr>
  <tr>
    <td>Quantity</td><td>type (`quantity<metre> q(2);`)</td><td>type (`quantity<si::length> q(2 * si::meter);`)</td><td></td><td></td><td>value of unit (`length::meter_t d(220);`)</td><td></td>
  </tr>
  <tr>
    <td>Literal instance</td><td>UDL (`123m`)</td><td>Number * static constant (`123 * si::meters`)</td><td></td><td></td><td>UDL (`123_m`)</td><td></td>
  </tr>
  <tr>
    <td>Variable instance</td><td>constructor (`quantity<metre>(v)`)</td><td>Variable * static constant (`d * si::meters`)</td><td></td><td></td><td>constructor (`length::meter_t(v)`)</td><td></td>
  </tr>
  <tr>
    <td>Any representation</td><td>yes</td><td>yes</td><td></td><td>no (macro to set the default type)</td><td>no (macro to set the default type)</td><td></td>
  </tr>
  <tr>
    <td>Quantity template arguments type deduction</td><td>yes</td><td>yes</td><td></td><td></td><td>no</td><td></td>
  </tr>
  <tr>
    <td>System support</td><td>no</td><td>yes</td><td></td><td></td><td>no</td><td></td>
  </tr>
  <tr>
    <td>C++ Concepts</td><td>yes</td><td>no</td><td>no</td><td>no</td><td>no</td><td>no</td>
  </tr>
  <tr>
    <td>Types downcasting</td><td>yes</td><td>no</td><td>no</td><td>no</td><td>no</td><td>no</td>
  </tr>
  <tr>
    <td>Implicit unit conversions</td><td>same dimension non-truncating only</td><td>no</td><td></td><td></td><td></td><td></td>
  </tr>
  <tr>
    <td>Explicit unit conversions</td><td>`quantity_cast`</td><td>`quantity_cast`</td><td></td><td></td><td></td><td></td>
  </tr>
  <tr>
    <td>Temperature support</td><td>Kelvins only + conversion functions</td><td>Kelvins only + dedicated systems</td><td></td><td></td><td></td><td></td>
  </tr>
  <tr>
    <td>String output</td><td>TBD</td><td>yes</td><td></td><td></td><td>yes</td><td></td>
  </tr>
  <tr>
    <td>String input</td><td>no</td><td>no</td><td></td><td></td><td>no</td><td></td>
  </tr>
  <tr>
    <td>Macros in the user interface</td><td>no</td><td>yes</td><td></td><td></td><td>yes</td><td></td>
  </tr>
  <tr>
    <td>Non-linear scale support</td><td>no</td><td>no</td><td></td><td></td><td>yes</td><td></td>
  </tr>
  <tr>
    <td></td><td></td><td></td><td></td><td></td><td></td><td></td>
  </tr>
</table>



Fundamental concerns with current solutions {#concerns}
=======================================================

Feedback from the users gathered so far signals the following major complaints:
- Bad user experience caused by hard to understand and analyse compile-time errors and poor
    debugging experience.
- Too high entry bar. (Boost.Units is claimed to require expertise in both C++ and dimensional analysis.)
- Unnecessary intermediate conversions to [=base units=] resulting in a runtime overhead and loss of precision.
- Poor support for really large or small ratios. (i.e. `eV`)
- Safety and security connected problems with the usage of an external 3rd party library for production purposes.
- Impossibility or really hard extensibility of the library with new [=base dimensions=].


Design principles {#design-principles}
======================================

(Enumerate basic design principles)

1. Safety and performance
    - strong types
    - compile-time safety
    - constexpr all the things
2. The best possible user experience
    - compiler errors
    - debugging
3. No macros in the user interface
4. Easy extensibility
5. No external dependencies
6. Possibility to be standardized as a freestanding part of the C++ Standard Library

(other ideas)

- Be consistent


Improving user experience {#user-experience}
============================================

Type aliasing issues {#type-aliasing-issues}
--------------------------------------------

Type aliases benefit developers but not end users. As a result users end up with huge error messages.

Code developer works with the following syntax:

```cpp
constexpr bu::quantity<bu::si::velocity> avg_speed(bu::quantity<bu::si::length> d, bu::quantity<bu::si::time> t)
{ return d * t; }
```

If the error happens in such a code user sees the following error for gcc-8:

```
error: could not convert ‘boost::units::operator*(const boost::units::quantity<Unit1, X>&,
const boost::units::quantity<Unit2, Y>&) [with Unit1 = boost::units::unit<boost::units::list<boost::units::dim
<boost::units::length_base_dimension, boost::units::static_rational<1> >, boost::units::dimensionless_type>,
boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, 
boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10,
boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit,
boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit,
boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit,
boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit,
boost::units::dimensionless_type> > > > > > > > > > >; Unit2 = boost::units::unit<boost::units::list<boost::units::dim
<boost::units::time_base_dimension, boost::units::static_rational<1> >, boost::units::dimensionless_type>, 
boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, 
boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10,
boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list
<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list
<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list
<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit,
boost::units::dimensionless_type> > > > > > > > > > >; X = double; Y = double; typename
boost::units::multiply_typeof_helper<boost::units::quantity<Unit1, X>, boost::units::quantity<Unit2, Y> >::type =
boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension,
boost::units::static_rational<1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension,
boost::units::static_rational<1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system
<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit
<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >,
boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit,
boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit,
boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit,
boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >,
void>, double>](t)’ from ‘quantity<unit<list<[...],list<dim<[...],static_rational<1>>,[...]>>,[...],[...]>,[...]>’
to ‘quantity<unit<list<[...],list<dim<[...],static_rational<-1>>,[...]>>,[...],[...]>,[...]>’
     return d * t;
            ~~^~~
```

This is only the very first line of the compilation error log. The same error for clang-7 looks as follows:

```
error: no viable conversion from returned value of type 'quantity<unit<list<[...], list<dim<[...],
static_rational<1, [...]>>, [...]>>, [...]>, [...]>' to function return type 'quantity<unit<list<[...], list<dim<[...],
static_rational<-1, [...]>>, [...]>>, [...]>, [...]>'
    return d * t;
           ^~~~~
```

Despite being shorter, this message too does not help much in finding the actual error.

Omnipresent type aliasing does not affect only compilation errors but also debugging. Here is how a breakpoint
for above function looks like in the gdb debugger:

```
Breakpoint 1, avg_speed<boost::units::heterogeneous_system<boost::units::heterogeneous_system_impl
<boost::units::list<boost::units::heterogeneous_system_dim<boost::units::si::meter_base_unit, boost::units::static_rational<1> >, 
boost::units::dimensionless_type>, boost::units::list<boost::units::dim<boost::units::length_base_dimension, 
boost::units::static_rational<1> >, boost::units::dimensionless_type>, boost::units::list<boost::units::scale_list_dim
<boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::dimensionless_type> > >, 
boost::units::heterogeneous_system<boost::units::heterogeneous_system_impl<boost::units::list
<boost::units::heterogeneous_system_dim<boost::units::scaled_base_unit<boost::units::si::second_base_unit, 
boost::units::scale<60, boost::units::static_rational<2> > >, boost::units::static_rational<1> >, 
boost::units::dimensionless_type>, boost::units::list<boost::units::dim<boost::units::time_base_dimension, 
boost::units::static_rational<1> >, boost::units::dimensionless_type>, boost::units::dimensionless_type> > > (d=..., t=...) at 
velocity_2.cpp:39
39        return d / t;
```

Downcasting facility {#downcasting}
-----------------------------------

In order to provide much shorter error messages the author of the paper with the help of Richard Smith
implemented a downcast facility in [[MP-UNITS]]. It allowed to convert the following error log from:

```
[with T = units::quantity<units::unit<units::dimension<units::exp<units::base_dim_time, 1> >, std::ratio<1> >, long long int>]
```

Into:

```
[with T = units::quantity<units::second, long long int>]
```

Downcasting facility provides a type substitution mechanism. It connects a specific primary template
class specialization with a strong type assigned by the user. A simplified mental model of the
facility may be represented as:

```cpp
struct metre : unit<dimension<exp<base_dim_length, 1>>, std::ratio<1, 1, 0>>; 
```

In the above example `metre` is a downcasting target (child class) and a specific `unit` class 
template specialization is a downcasting source (base class). The downcasting facility provides
one to one type substitution mechanism. Only one child class can be created for a specific base class
template instantiation.

Downcasting facility is provided through two dedicated types, a concept, and a few helper template aliases.

```cpp
template<typename BaseType>
struct downcast_base {
  using base_type = BaseType;
  friend auto downcast_guide(downcast_base);
};
```

`units::downcast_base` is a class that implements the CRTP idiom, marks the base of downcasting
facility with a `base_type` member type, and provides a declaration of the downcasting ADL friendly
(Hidden Friend) entry point member function `downcast_guide`. An important design goal is that
this function does not return any specific type in its declaration. This non-member function
is going to be defined in a child class template `downcast_helper` and will return a target
type of the downcasting operation there.

```cpp
template<typename T>
concept Downcastable =
    requires {
      typename T::base_type;
    } &&
    std::derived_from<T, downcast_base<typename T::base_type>>;
```

`units::Downcastable` is a concepts that verifies if a type implements and can be used in a downcasting
facility.

```cpp
template<typename Target, Downcastable T>
struct downcast_helper : T {
  friend auto downcast_guide(typename downcast_helper::downcast_base) { return Target(); }
};
```

`units::downcast_helper` is another CRTP class template that provides the implementation of a
non-member friend function of the `downcast_base` class template which defines the target
type of a downcasting operation. It is used in the following way to define `dimension` and
`unit` types in the library:

```cpp
template<typename Child, Exponent... Es>
struct derived_dimension : downcast_helper<Child, detail::make_dimension_t<Es...>> {};
```

```cpp
template<typename Child, Dimension D>
struct derived_unit<Child, D, R> : downcast_helper<Child, unit<D, ratio<1>>> {};
```

With such CRTP types, the only thing the user has to do to register a new type for the downcasting
facility is to publicly derive from one of those CRTP types and provide its new child type as
the first template parameter of the CRTP type.

```cpp
struct metre : derived_unit<metre, length> {};
```

Above types are used to define base and target of a downcasting operation. To perform the actual
downcasting operation a dedicated template alias is provided:

```cpp
template<Downcastable T>
using downcast_target = decltype(detail::downcast_target_impl<T>());
```

`units::downcast_target` is used to obtain the target type of the downcasting operation registered
for a given specialization in a base type.

For example to determine a downcasted type of a quantity multiply operation the following can be done: 

```cpp
using dim = dimension_multiply_t<typename U1::dimension, typename U2::dimension>;
using common_rep = decltype(lhs.count() * rhs.count());
using ret = quantity<downcast_target<unit<dim, ratio_multiply<typename U1::ratio, typename U2::ratio>>>, common_rep>;
```

`detail::downcast_target_impl` checks if a downcasting target is registered for the specific base class.
If yes it returns the registered type, otherwise it works like a regular identity type returning
a provided base class. 

```cpp
namespace detail {

  template<typename T>
  concept has_downcast = requires {
    downcast_guide(std::declval<downcast_base<T>>());
  };

  template<typename T>
  constexpr auto downcast_target_impl()
  {
    if constexpr(has_downcast<T>)
      return decltype(downcast_guide(std::declval<downcast_base<T>>()))();
    else
      return T();
  }

}
```


Template instantiation issues {#template-instantiation-issues}
--------------------------------------------------------------

Errors inside implementation details caused by invalid instantiations.


Concepts {#concepts}
--------------------

Error messages before instantiating a template rather than a compilation error deeply nested in the class implementation.

```
example.cpp: In instantiation of ‘constexpr units::Velocity avg_speed(D, T)
    [with D = units::quantity<units::kilometre>; T = units::quantity<units::hour>]’:
example.cpp:49:49:   required from here
example.cpp:34:14: error: placeholder constraints not satisfied
    34 |   return d * t;
       |              ^
include/units/dimensions/velocity.h:34:16: note: within ‘template<class T> concept units::Velocity<T>
    [with T = units::quantity<units::unit<units::dimension<units::exp<units::base_dim_length, 1, 1>,
                units::exp<units::base_dim_time, 1, 1> >, units::ratio<3600000, 1> >, double>]’
    34 |   concept Velocity = Quantity<T> && std::same_as<typename T::dimension, velocity>;
       |           ^~~~~~~~
include/stl2/detail/concepts/core.hpp:37:15: note: within ‘template<class T, class U> concept std::same_as<T, U>
    [with T = units::dimension<units::exp<units::base_dim_length, 1, 1>, units::exp<units::base_dim_time, 1, 1> >;
          U = units::velocity]’
    37 |  META_CONCEPT same_as = meta::Same<T, U> && meta::Same<U, T>;
       |               ^~~~~~~
include/meta/meta_fwd.hpp:224:18: note: within ‘template<class T, class U> concept meta::Same<T, U>
    [with T = units::dimension<units::exp<units::base_dim_length, 1, 1>, units::exp<units::base_dim_time, 1, 1> >;
          U = units::velocity]’
   224 |     META_CONCEPT Same =
       |                  ^~~~
include/meta/meta_fwd.hpp:224:18: note: ‘meta::detail::barrier’ evaluated to false
include/meta/meta_fwd.hpp:224:18: note: within ‘template<class T, class U> concept meta::Same<T, U>
    [with T = units::velocity;
          U = units::dimension<units::exp<units::base_dim_length, 1, 1>, units::exp<units::base_dim_time, 1, 1> >]’
include/meta/meta_fwd.hpp:224:18: note: ‘meta::detail::barrier’ evaluated to false
```


Easy to use and hard to abuse {#easy-to-use-hard-to-abuse}
==========================================================

- Consistency with `std::chrono` behavior.
- Clear responsibility of each type (base_dimension -> exp -> dimension -> unit -> quantity).
- Easy to extend with custom dimensions or units.
- Easy to understand error messages thanks to downcast facility and concepts.
- No isolated abstraction for [=systems=] that would complicate implementation and reasoning.


Limiting intermediate conversions {#limiting-intermediate-value-conversions}
============================================================================


Template arguments type deduction {#arguments-type-deduction}
-------------------------------------------------------------

```cpp
template<typename U1, typename Rep1, typename U2, typename Rep2>
constexpr auto avg_speed(units::length<U1, Rep1> d, units::time<U2, Rep2> t)
{
  return d / t;
}
```

[Please note that support for above syntax was removed from [[MP-UNITS]] after the feedback from Cologne ISO meeting]

Concepts for function arguments {#concepts-for-arguments}
---------------------------------------------------------

```cpp
constexpr auto avg_speed(units::Length auto d, units::Time auto t)
{
  return d / t;
}
```

Concepts for return types {#concepts-for-return-types}
------------------------------------------------------

```cpp
constexpr units::Velocity auto avg_speed(units::Length auto d, units::Time auto t)
{
  return d / t;
}
```

Concept `auto` for intermediate results {#concept-auto-for-intermediate-results}
--------------------------------------------------------------------------------

```cpp
const units::Velocity auto speed = avg_speed(220.km, 2.h);
```


Extensibility {#extensibility}
==============================

Base dimensions


Design decisions {#design-decisions}
====================================

UDL vs multiply syntax {#udl-vs-multiply}
-----------------------------------------

User convenience for implementing derived units
Problems with downcasting


Mixed syntax {#mixed}
---------------------

```cpp
constexpr auto d1 = 1000 * meter(1);
constexpr auto d2 = meter(1000);
constexpr auto d3 = kilo * meter(1);
constexpr auto d4 = 1k*m;
constexpr auto d5 = (k*m)(1);

constexpr auto v1 = quantity<meter/second>(10);
constexpr auto v2 = quantity<m/s>(10);
constexpr auto v3 = meter(10)/second(1);
constexpr auto v4 = meter(10)/second();
constexpr auto v5 = meter(10)/second;
constexpr auto v6 = m(10)/s;
constexpr auto v7 = (m/s)(10);
constexpr auto v8 = 10m/s;
```

NTTP usage {#nttp-usage}
------------------------

There are a few points in the physical units domain design that could benefit from Non-Type
Template Parameters usage. One of the most obvious cases here is `ratio`. A classical
implementation of such a class template looks like this:

```cpp
template<intmax_t Num, intmax_t Den = 1>
struct ratio {
  static constexpr intmax_t num = Num * static_sign<Den>::value / static_gcd<Num, Den>::value;
  static constexpr intmax_t den = static_abs<Den>::value / static_gcd<Num, Den>::value;
  using type = ratio<num, den>;
};
```

In addition, it provides a few utilities to do operations on such types:

```cpp
namespace detail {
  template<typename R1, typename R2>
  struct ratio_multiply_impl {
  private:
    static constexpr intmax_t gcd1 = static_gcd<R1::num, R2::den>::value;
    static constexpr intmax_t gcd2 = static_gcd<R2::num, R1::den>::value;
  public:
    using type = ratio<safe_multiply<(R1::num / gcd1), (R2::num / gcd2)>::value,
                       safe_multiply<(R1::den / gcd2), (R2::den / gcd1)>::value>;
    static constexpr intmax_t num = type::num;
    static constexpr intmax_t den = type::den;
  };
}
template<typename R1, typename R2>
using ratio_multiply = detail::ratio_multiply_impl<R1, R2>::type;
```

Usage examples of such an approach looks as follows:

```cpp
struct yard : derived_unit<yard, length, ratio<9'144, 10'000>> {};
struct foot : derived_unit<foot, length, ratio_multiply<ratio<1, 3>, yard::ratio>> {};
struct inch : derived_unit<inch, length, ratio_multiply<ratio<1, 12>, foot::ratio>> {};
struct mile : derived_unit<mile, length, ratio_multiply<ratio<1'760>, yard::ratio>> {};
```

With NTTP the implementation and usage of `ratio` is much easier:

```cpp
struct ratio {
  std::intmax_t num;
  std::intmax_t den;

  explicit constexpr ratio(std::intmax_t n, std::intmax_t d = 1) :
    num(n * (d < 0 ? -1 : 1) / std::gcd(n, d)),
    den(abs(d) / std::gcd(n, d))
  {
  }

  [[nodiscard]] constexpr bool operator==(const ratio&) = default;

  [[nodiscard]] friend constexpr ratio operator*(const ratio& lhs, const ratio& rhs)
  {
    const std::intmax_t gcd1 = std::gcd(lhs.num, rhs.den);
    const std::intmax_t gcd2 = std::gcd(rhs.num, lhs.den);
    return ratio(safe_multiply(lhs.num / gcd1, rhs.num / gcd2),
                 safe_multiply(lhs.den / gcd2, rhs.den / gcd1));
  }

  [[nodiscard]] friend consteval ratio operator*(std::intmax_t n, const ratio& rhs)
  {
    return ratio(n) * rhs;
  }

  [[nodiscard]] friend consteval ratio operator*(const ratio& lhs, std::intmax_t n)
  {
    return lhs * ratio(n);
  }
};
```

```cpp
// US customary units
struct yard : derived_unit<yard, length, ratio(9'144, 10'000)> {};
struct foot : derived_unit<foot, length, yard::ratio / 3> {};
struct inch : derived_unit<inch, length, foot::ratio / 12> {};
struct mile : derived_unit<mile, length, 1'760 * yard::ratio> {};
```


Relative vs absolute quantity {#relative-vs-absolute}
-----------------------------------------------------

One of the most important aspects of the physical units library is to understand what is a [=quantity=]?
A absolute or a relative value? For most dimensions only relative values have sense. For example:
- Where is absolute 123 meters?
- If I am sitting in a moving train is my velocity == 0?
- Is my velocity == 0 when the train stops?

However, for some dimensions like temperature absolute values are really needed. For example how much is
`0 ℃ + 0 ℃`? Is it `0 ℃` or `0 ℃` or `273.15 ℃`? Yes, the repeated value of `0 ℃` is not an error here ;-)
Actually all of the answers are right:
- Two (absolute) temperatures:

    ```
    0 ℃ + 0 ℃ = 273.15 K + 273.15 K = 546.30 K = 273.15 ℃
    ```

- A (absolute) temperature and a (relative) temperature interval:

    ```
    0 ℃ + 0 ℃ = 273.15 K + 0 K = 273.15 K = 0 ℃
    ```

- Two (relative) temperature intervals:

    ```
    0 ℃ + 0 ℃ = 0 K + 0 K = 0 K = 0 ℃
    ```

As proven above it is a complex and a pretty hard problem. Average usage of the library will probably not
be able to distinguish between different kinds of quantities. This is why it was decided that only relative
quantity values will be modeled by the library. Moreover, providing support for only relative quantities
of other temperature units than Kelvin will probably still be misused by the users. This is why it was
decided to support only Kelvins as built-in temperature units and provide verbose non-member utility
functions for conversions between different kind of temperature values and their units. 


Open questions {#open-questions}
================================

Should we support [=systems=] as a separate type {#systems-support}
---------------------------------------------------------------

US Customary System has the same dimensions and most of the units as SI with the differences scoped
mostly only in length and mass units and derived dimensions using those. It is much simpler to use
the common definitions of such dimensions and just provide units dedicated to such system together
with SI (i.e. meters and miles).

Even systems that seems to be totally isolated from typical SI uses cases like `coffee/milk/water/sugar`
system at some point will probably need time, volume and other SI dimensions too.

Boost.Units uses [=systems=] mostly to provide a capability of having a different [=base unit=] for a dimension
to limit intermediate conversions while passing quantities as vocabulary types in the interfaces.
Usage of templates constrained with concepts for generic algorithms and concrete types for domain
specific need addresses this area easily.

(Example of a generic interface i.e. avg_speed with miles)

(Example of a domain specific interface i.e. eV)


Compatibility with `std::chrono::duration` {#duration-compatibility}
--------------------------------------------------------------------


Should we provide integral UDLs {#integral-udl}
-----------------------------------------------

- Yes, as is (always both integral and floating-point for all units).
- Yes, but with floating `Rep`.
- Yes, but only for specific units like `bit`, `byte`, etc. where floating-point types doo not have much sense (no floating point UDLs).
- No, just use floating-point UDLs for all (no integral UDLs).


Should we provide `seconds<int>` or stay with `quantity<second, int>`? {#seconds-int}
-------------------------------------------------------------------------------------


Should we provide support for dimensionless quantities? {#dimensionless-quantities}
-----------------------------------------------------------------------------------



Impact on the Standard {#impact}
================================



Implementation Experience {#implementation}
===========================================

Author of this document implemented `mp-units` [[MP-UNITS]] library where he tested different ideas and 
proved implementability of the features described in the paper. The library framework consists of a few
concepts: [=quantities=], [=units=], [=dimensions=] and their exponents. From the user's point of view
the most important is a [=quantity=].

[=Quantity=] is a concrete amount of a unit for a specified dimension with a specific representation:

```cpp
units::quantity<units::kilometre, double> d1(123);
auto d2 = 123km;    // units::quantity<units::kilometre, std::int64_t>
```

There are C++ concepts provided for each such quantity type:

```cpp
template<typename T>
concept Length = QuantityOf<T, length>;
```

With these concepts we can easily write a function template:

```cpp
constexpr units::Velocity auto avg_speed(units::Length auto d, units::Time auto t)
{
  return d / t;
}
```

This template function can be used in the following way:

```cpp
const units::quantity<units::kilometre> d(220);
const units::quantity<units::hour> t(2);
const units::Velocity auto kmph = units::quantity_cast<units::kilometre_per_hour>(avg_speed(d, t));
std::cout << kmph.count() << " km/h\n";

const units::Velocity auto speed = avg_speed(140.mi, 2.h);
assert(speed.count() == 70);
std::cout << units::quantity_cast<units::mile_per_hour>(speed).count() << " mph\n";
```

This guarantees that no intermediate conversions are being made and the output binary is as
effective as implementing the function with `double`s.

Additionally, thanks to extensive usage of the C++ concepts and the downcasting facility, the library
provides great user experience. The error message for type aliases would look like:

```
[with D = units::quantity<units::unit<units::dimension<units::exp<units::base_dim_length, 1, 1>,
                units::exp<units::base_dim_time, 1, -1> >, units::ratio<5, 18> >, double>]
```

Yet, thanks to downcast facility the actual error message is:

```
[with D = units::quantity<units::kilometre_per_hour, double>]
```

The breakpoint in the debugger became readable as well:

```
Breakpoint 1, avg_speed<units::quantity<units::kilometre, double>,
                        units::quantity<units::hour, double> >
(d=..., t=...) at velocity.cpp:31
31      return d / t;
```

Moreover, it is really easy to extend the library with custom units, derived units, and base dimensions. For example, if the
user wants to provide a custom `digital information` base dimension and new units based on it, only minimal code is required:

```cpp
#include <units/quantity.h>

// custom base dimension
struct base_dim_digital_information { static constexpr const char* value = "digital information"; };

// custom derived dimension and its concept
struct digital_information : units::derived_dimension<digital_information, units::exp<base_dim_digital_information, 1>> {};

template<typename T>
concept DigitalInformation = units::QuantityOf<T, digital_information>;

// custom units and their units
struct bit : units::derived_unit<bit, digital_information> {};
struct byte : units::derived_unit<byte, digital_information, units::ratio<8>> {};

inline namespace literals {
  constexpr auto operator""_b(unsigned long long l) { return units::quantity<bit, std::int64_t>(l); }
  constexpr auto operator""_b(long double l) { return units::quantity<bit, long double>(l); }

  constexpr auto operator""_B(unsigned long long l) { return units::quantity<byte, std::int64_t>(l); }
  constexpr auto operator""_B(long double l) { return units::quantity<byte, long double>(l); }
}

// unit tests
static_assert(1_B == 8_b);
```

Polls {#polls}
==============

1. Do we want a physical units library in the C++ standard?
2. Do we want to have support for digital information dimensions in the initial version of the library?
3. Do we prefer UDL, multiply, or mixed syntax for units?
4. Do we like concept-based approach to prevent truncation?
5. Do we like downcasting facility or do we want to wait for other solutions (strong types in the
    language, better compiler errors, ...)?
6. Do we prefer NTTP usage for `ratio` and `exp`?
7. Do we want to require explicit casts between different units of the same dimension or do we
    allow `chrono`-like implicit conversions (floating-point representation and non-truncating
    integer conversions)?
8. Do we agree with Kelvins only support for temperature and verbose conversion functions for other
    units and absolute temperatures?
9. Which option of UDLs do we prefer ([[#integral-udl]])?
10. Should we provide `seconds<int>` or stay with `quantity<second, int>`?
11. Should we provide support for dimensionless quantities?
12. Should American spelling be provided? (`meter` vs `metre`, `ton` vs `tonne`, ...)
13. Do we want to introduce a dedicated system type?


Acknowledgements {#acknowledgements}
====================================

Special thanks and recognition goes to [Epam Systems](http://www.epam.com) for supporting my
membership in the ISO C++ Committee and the production of this proposal.

<pre class=biblio>
{
    "MARS_ORBITER": {
        "href": "https://en.wikipedia.org/wiki/Mars_Climate_Orbiter",
        "title": "Mars Climate Orbiter",
        "publisher": "Wikipedia"
    },
    "COLUMBUS": {
        "href": "https://en.wikipedia.org/wiki/Christopher_Columbus",
        "title": "Christopher Columbus",
        "publisher": "Wikipedia"
    },
    "GIMLI_GLIDER": {
        "href": "https://en.wikipedia.org/wiki/Gimli_Glider",
        "title": "Gimli Glider",
        "publisher": "Wikipedia"
    },
    "CLARENCE": {
        "authors": [ "Steve Chawkins" ],
        "href": "https://www.latimes.com/archives/la-xpm-2001-feb-09-me-23253-story.html",
        "title": "Mismeasure for Measure",
        "publisher": "Los Angeles Times"
    },
    "DISNEY": {
        "href": "https://web.archive.org/web/20040209033827/http://www.olc.co.jp/news/20040121_01en.html",
        "title": "Cause of the Space Mountain Incident Determined at Tokyo Disneyland Park",
        "publisher": "Oriental Land Co., Ltd."
    },
    "FLIGHT_6316": {
        "href": "https://ntsb.gov/news/press-releases/Pages/Korean_Air_Flight_6316_MD-11_Shanghai_China_-_April_15_1999.aspx",
        "title": "Korean Air Flight 6316 MD-11, Shanghai, China - April 15, 1999",
        "publisher": "National Transportation Safety Board"
    },
    "WILD_RICE": {
        "href": "https://www.bizjournals.com/eastbay/stories/2001/07/09/focus3.html",
        "title": "Manufacturers, exporters think metric",
        "publisher": "San Francisco Business Times"
    },
    "MP-UNITS": {
        "authors": [ "Mateusz Pusz" ],
        "href": "https://github.com/mpusz/units",
        "title": "mp-units"
    },
    "BOOST.UNITS": {
        "authors": [ "Steven Watanabe", "Matthias C. Schabel" ],
        "href": "https://www.boost.org/doc/libs/1_70_0/doc/html/boost_units.html",
        "title": "Boost.Units",
        "publisher": "Boost"
    },
    "CPPNOW17-UNITS": {
        "authors": [ "Steven Watanabe" ],
        "href": "https://github.com/swatanabe/cppnow17-units",
        "title": "cppnow17-units"
    },
    "PHYSUNITS-CT-CPP11": {
        "authors": [ "Martin Moene" ],
        "href": "https://github.com/martinmoene/PhysUnits-CT-Cpp11",
        "title": "PhysUnits-CT-Cpp11"
    },
    "NIC_UNITS": {
        "authors": [ "Nic Holthaus" ],
        "href": "https://github.com/nholthaus/units",
        "title": "units"
    },
    "BRYAN_UNITS": {
        "authors": [ "Bryan St. Amour" ],
        "href": "https://github.com/bstamour/units",
        "title": "units"
    },
    "BENRI": {
        "authors": [ "Jan Sende" ],
        "href": "https://github.com/jansende/benri",
        "title": "benri"
    },
    "MIKEFORD3_UNITS": {
        "authors": [ "Michael Ford" ],
        "href": "https://github.com/mikeford3/units",
        "title": "units"
    }

}
</pre>
